\chapter{Przykłady działania}
W trakcie prac został podłączony po MQTT sterownik przekaźnikowy, który sterował lampką oraz czujnik temperatury DS18B20 do platformy, która działała na urządzeniu Raspberry Pi oraz na laptopie. Płytka Raspberry została wykorzystana z kilku względów. 
\begin{itemize}
    \item Małe rozmiary dzięki którym łatwiej nam znaleźć dedykowane stałe miejsce.
    \item Małe zapotrzebowanie na energie, które ma bardzo duży wpływ w przypadku gdy urządzenie działa 24 godziny na dobę.
    \item Mała cena, która wynosi ok 200 zł za wersje 3B+.
\end{itemize}
Oczywiście to urządzenie ma dwie spore wady.
\begin{itemize}
    \item Mała stabilność, która jest efektem tego, że system działa na karcie SD.
    \item Do tego urządzenia musimy sami dostarczyć zasilanie 5V o minimalnym natężeniu 2A. Często z winy słabej jakości kabla albo zasilacza awaryjność powoduje, że musimy restartować urządzenie raz na miesiąc czy nawet na tydzień.
\end{itemize}
Warto jednak tutaj wspomnieć jednak że niektórzy miłośnicy Raspberry instalują system na dysku ssd co znacznie wydłuża żywotność i przy lekkich platformach system potrafi pracować wiele lat bez przerwy spowodowanej awarią. Eliminuje to nam pierwszą wadę urządzenia lecz można się z tym raczej spotkać tylko w hobbistycznych projektach, a nie w komercyjnych rozwiązaniach.
\par
Wady i zalety pokazują, że jest to świetna konfiguracja prototypownia, a nie do długoterminowej instalacji. Jako że grupa docelowa tej platformy głównie korzysta z tego urządzenia to postanowiłem na nim stworzyć przykładową implementację.
\newpage
\section{Shelly}
Najbardziej kosztownym czasowo punktem było zintegrowanie platformy ze sterownikiem Shelly1 który może być sterowany przez protokół mqtt. 
\begin{figure}[h]
  \includegraphics[width=\linewidth]{shelly1.jpg}
  \caption{Shelly1}
  \label{fig:shelly}
\end{figure}
API jest udostępnione na stronie producenta i praca polegała na zintegrowaniu sterownika z serwerem.
API dla sterownika Shelly1 wygląda następująco:
\begin{itemize}
    \item shellies/<model>-<deviceid>/relay/0 by zareportować \textit{on} lub \textit{off}
    \item shellies/<model>-<deviceid>/relay/0/command akceptuje \textit{on} lub \textit{off}
    \item shellies/<model>-<deviceid>/input/0 reportuje stan wejścia SW
    \item shellies/<model>-<deviceid>/longpush/0 reportuje stan długiego wciśnięcia jako 0 lub 1
\end{itemize}
dochodzi jeszcze jeden ogólny kanał dla każdego modelu \textit{shellies/announce} na którym "przedstawia się" każdy nowo podłączony sterownik.
\newpage
\begin{lstlisting}[columns=fullflexible,caption={sterowanie shelly}\label{lst:shelly},language=Java]
const shellies = {};
export const setRelay = (id, state) => {
	client.publish(`shellies/${id}/relay/0/command`, state);
};
const messageHandler = (deviceId, prop, message) => {
	if (shellies[deviceId] !== undefined) {
		shellies[deviceId][prop] = message;
		onDeviceChange({
			id: deviceId,
			...shellies[deviceId]
		});
	}
};
client.on('message', (topic, message) => {
	if (topic === 'shellies/announce') {
		const announcement = JSON.parse(message.toString());
		console.log('new shelly: ', announcement.id);
		shellies[announcement.id] = { ip: announcement.ip };
	} else {
		const id = topic.split('/')[1];
		const prop = topic.split('/')[2];
		messageHandler(id, prop, message.toString());
	}
});
\end{lstlisting}
\section{DS18B20}
DS18B20 to termomentr cyfrowy obsługiwany przez protokół 1-wire. W przedstawionej implementacji jest on podłączony w trybie \textit{paraside} na 2 żyły gdzie jedna to masa, a druga jest jednocześnie zasilaniem jak i linią danych. 
\par Implementacja jest znacznie łatwiejsza niż w przypadku Shelly ponieważ ogranicza sie do pobrania modułu \textit{ds18b20-raspi} z repozytorium npm i skonfigurowania wyjść raspberry. \\
Konfiguracja ogranicza się do włączeniu obsługi interface'u 1-wire w ustawieniach urządzenia. Czujnik został podłączony do domyślnego portu którym jest GPIO4. Efekt końcowy widać na zdjęciu \ref{fig:finalGPIOConnections}
\par Możemy czytać wartość pomiaru przy użyciu jednej funkcji w 2 wariantach: synchronicznej \ref{lst:ds18b20sync} i asynchronicznej \ref{lst:ds18b20async}. Moduł exportuje funkcję \textit{readDataWithInterval} który odczytuje wartość co 30 sekund. Skraca to implementację w module głównym.
\newpage
\begin{lstlisting}[columns=fullflexible,caption={ds18b20.js}\label{lst:ds18b20},language=Java]
import sensor from 'ds18b20-raspi'
const intervalsId = [];

export const readTemp = (id) => {
    return new Promise((resolve, reject) => {
        sensor.readC(id, 2, (err, temp) => { /*!\annotation{lst:ds18b20async}!*/
            if (err) {
                reject(err)
            } else {
                resolve(temp);
            }
        })
    })
}

export const readDataWithInterval = (id, callback) => {
    intervalsId.push(setInterval(() => {
        const temp = sensor.readC(id) /*!\annotation{lst:ds18b20sync}!*/
        callback(temp, id);
    }, 30000))
}

export const clearAllTasks = () => {
    intervalsId.forEach(intervalId => clearInterval(intervalId))
}
\end{lstlisting}
\begin{figure}[h]
  \includegraphics[width=\linewidth]{gpio.jpg}
  \caption{podłączenie czujnika DS18B20}
  \label{fig:finalGPIOConnections}
\end{figure}